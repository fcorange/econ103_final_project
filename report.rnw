%% LyX 2.0.6 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass{article}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}
\usepackage{breakurl}
\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(replace.assign=TRUE,width=90)
@

\title{Stat 243 Final Project}

\author{Zixiao Chen}

\maketitle

\section{Sampling and Updating}
The sampling and updating steps are performed in a while loop. While desired the sample size \texttt{n} is not reached, the function continue to sample and update if needed. In the sampling step, we first need to find the cumulative areas under each piece-wise curve $s_{k}(x)$ from $z_{j-1}$ to $z_{j}$. The \texttt{sample\_val()} function will return a vector of $x^{*}$ and $u^{*}$ sampled. Then we need to compute $u_{k}(x^{*})$ and $l_{k}(x^{*})$ and pass these parameters into \texttt{squeeze\_test} and \texttt{rejection\_test}. If squeeze test fails and $h_{k}(x^{*})$ is evaluated, then we need to add this point $x^{*}$ into our initial set of $x$'s $T_{k}$, and update all the changes accordingly with the \texttt{update()} function.

\subsection{Sampling}
Now we have $k=5$ initial points in $T_{k}$ and $k$ tangent lines which intersect at $z_{j}, j=1,...,k-1$. These partition our area under the curve $s_k(x)$ into $k$ pieces, each including one point in $T_{k}$. For example, piece $j$ under the curve contains $x_{j}$, and its bounds are $z_{j-1}$ and $z_{j}$. We want to sample an $x^{*}$ from the curve $s_{k}(x)$, and a random number $u^{*}$ from \texttt{uniform(0,1)}.

\begin{enumerate}
  \item To sample an $x^{*}$ from $s_k(x)$, we are going to do this in two steps:
  \begin{itemize}
    \item Sample one piece from the $k$ pieces using a random number $u^{'}$: 
    
    In order to do this, we need to calculate the total area under the curve and sample a uniform number $u^{'}$ from $(0, sum(Area))$. So this uniform number now is the area we want to cover with our sample $x^{*}$, i.e., we want $\int_{xlb}^{x^{*}}s_{k}(x)dx=u^{'}$. Given the cumulative area ($cumArea[i]$) for each piece $i$, we can tell by the value of $u^{'}$ which range $x^{*}$ will be in.
    \item Solving for $x^{*}$ in the chosen area:
    
    The next step would be to find the cdf of $s_{k}(x)$, and solve $cdf(x)=u$ for $x^{*}$ within the range. Since our $s_{k}(x)$ is piece-wise, our actual computation for $x^{*}$ is actually slightly different. The area we want to cover in a specific range can be expressed as $u^{'}-cumArea[i-1]$, and we then solve for $x^{*}$ such that $\int_{z_{j-1}}^{x^{*}}s_{k}(x)dx=u^{'}-cumArea[i-1]$. By doing all the algebra, we are able to find a closed form of $x^{*}$ depending on the slope $a$ and intercept $b$ of $u_{k}(x)$, $x_{j-1}$ and $u^{'}-cumArea[i-1]$. We want to solve $x^{*}$ where $\int_{z_{j-1}}^{x^{*}}s_{k}(x)=u^{'}-cumArea[i-1]$.
    
    By doing the integral, we get
    
    $$\frac{e^{ax+b}}{a}|^{x^{*}}_{z_{j-1}}=u^{'}-cumArea[i-1]$$ where $$a=h^{'}(x_{j}), b=h(x_{j})-ax_{j}$$
    
    Expanding everyting out and reorganizing the equation, we have:
    
    $$x^{*}=\frac{log[e^{az_{j-1}+1}+(u^{'}-cumArea[i-1])a]-b}{a}$$
    
    Note that we have two special cases here. When $i=1$, our starting value for $x^{*}$ is $T_k[1]$, since $z_{0}$ is not defined in our vector of $z_{j}$. Also, when the slope of $u_k(x)$ is zero for the chosen piece, we need to handle the algebra a little different.
    
    When the slope is zero, $e^{b}|^{x^{*}}_{z_{j-1}}=u^{'}-cumArea[i-1]$.
    
    $$x^{*}=e^{b}(u^{'}-cumArea[i-1])+z_{j-1}$$
  \end{itemize}
  \item Then sample $u^{*}$ from \texttt{uniform(0,1)}, which we would make use of in the squeezing and rejection tests. Finally, the \texttt{sample\_val()} function returns our sampled $x^{*}$ and $u^{*}$ to the parent function \texttt{ars()}
\end{enumerate}

\subsection{Squeezing Test and Rejection Test}
With $x^{*}$, $u^{*}$ and the values of $u_k(x)$ and $l_k(x)$ evaluated at $x^{*}$, we can now perform the squeezing test. If the squeezing test returns TRUE, then $x^{*}$ will be accepted and stored in our sample vecotr. Otherwise, $h_k(x^{*})$ will be evaluated and the rejection test will be performed. If the rejection test is passed, $x^{*}$ will be added intot the sample vector.


\subsection{Updating}
The code for the updating part is listed below (function \texttt{update()}):
<<code_update, eval=FALSE>>=
update <- function(x_star, data, u_k, l_k,h) { 
  with(data,{
    T_k <- sort(append(data$T_k, x_star))
    position <- (which(T_k == x_star) - 1)
    h_k <- append(data$h_k, compute_h_k(x_star, h), after = position)
    h_k_prime <- append(data$h_k_prime, grad(h, x_star), after = position)
    z_k <- compute_z_k(T_k, h_k, h_k_prime)
    z_k <- c(z_k,tail(T_k,n=1))
    A_k <- rep(0,length=length(T_k))
    data <- data.frame(T_k,h_k,h_k_prime,z_k,A_k)
    for (i in 1:length(T_k)) {                    
      A_k[i] <- A(i, data)
    }
    data$A_k <- A_k
    
    return(data)
  })
}
@

When $h(x^{*})$ and $h^{'}(x^{*})$ were evaluated, we need to update the data frame we had, namely, to add the $x^{*}$ into the $T_{k}$ vector so that the number of elements in $T_{k}$ goes from $k$ to $k+1$. To do so, $x^{*}$ is appended into the $T_{k}$ vector and then the vector is sorted. The position of the new $x^{*}$ is then recorded so that vectors $h\_k$, $h\_k\_prime$, $z\_k$ and $A\_k$ were all updated. Finally, $cumArea$ was updated as well based on the new $A\_k$ vector.

\subsection{Check Log-concavity}
When the user inputs the desired function, it is hard to check whether the input function is log-concave or not. Instead of writing an algorithm to check the log-concavity at this stage, we performed a bounding-check at each update. More specifically, when the data frame is updated, we will check on the mid-points of $T_{k}$, in terms of whether or not the upper and lower bounds are really bounding the values of the log-density, or in other words, we wish to have (for all the mid-points of $T_{k}$):

$$u(x)\geq h(x), l(x)\leq h(x)$$

If the data did not pass the test, a warning will be displayed and the \texttt{ars()} will stop processing. All of the above was done in function \texttt{check\_concave()}:

<<code_check_concavity, eval=FALSE>>=
check_concave <- function(data,h) {
  sample_points <- vector()
  for (i in 1:(length(data$T_k)-1)) {
    sample_points[i] <- mean(c(data$T_k[i],data$T_k[i+1]))
  }
  u_k <- vector()
  for (i in 1:length(sample_points)){
    u_k[i]<-compute_u_k(data,sample_points[i])(sample_points[i])
  } 
  l_k <- vector()
  for (i in 1:length(sample_points)){
    l_k[i]<-compute_l_k(data$T_k,data$h_k,sample_points[i])(sample_points[i])
  }
  return(sum((sum(u_k < h(sample_points))==0) + (sum(l_k > h(sample_points))==0)) == 2)
}
@

\subsection{Check User Input}
When user inputs the arguments to the \texttt{ars()} function, we have to make sure that the inputs are reasonable values. Namely, we will check the following items:
\begin{itemize}
  \item The sample size $n$ is an integer and is sufficiently large ($>5$ in our case)
  \item The density function $g$ is a function
  \item The upper bound $xub$ is larger than or equal to the lower bound $xlb$
\end{itemize}
This part was done using the following code:
<<code_check_input, eval=FALSE>>=
check_input <- function(g,n,xlb,xub) {
  if ((n<5)||(n%%1!=0)) {
    warning("Sample size must be a bigger integer")
    return()
  }
  if(xlb>=xub) {
    warning ("Lower bound must be smaller than the upper bound")
    return()
  }
  if (typeof(g)!="closure") {
    warning("Input density is not a function")
    return()
  }
}
@


\end{document}
